/*
Provisioning MnS

OAS 3.0.1 definition of the Provisioning MnS Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.

API version: 17.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi_ProvMnS

import (
	"encoding/json"
	"fmt"
)

// ResourcesSliceNrm - struct for ResourcesSliceNrm
type ResourcesSliceNrm struct {
	EPTransportSingle                            *EPTransportSingle
	FeasibilityCheckAndReservationJobSingle      *FeasibilityCheckAndReservationJobSingle
	MnS1                                         *MnS1
	NetworkSliceSingle                           *NetworkSliceSingle
	NetworkSliceSubnetProviderCapabilitiesSingle *NetworkSliceSubnetProviderCapabilitiesSingle
	NetworkSliceSubnetSingle                     *NetworkSliceSubnetSingle
	SubNetworkSingle2                            *SubNetworkSingle2
}

// EPTransportSingleAsResourcesSliceNrm is a convenience function that returns EPTransportSingle wrapped in ResourcesSliceNrm
func EPTransportSingleAsResourcesSliceNrm(v *EPTransportSingle) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		EPTransportSingle: v,
	}
}

// FeasibilityCheckAndReservationJobSingleAsResourcesSliceNrm is a convenience function that returns FeasibilityCheckAndReservationJobSingle wrapped in ResourcesSliceNrm
func FeasibilityCheckAndReservationJobSingleAsResourcesSliceNrm(v *FeasibilityCheckAndReservationJobSingle) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		FeasibilityCheckAndReservationJobSingle: v,
	}
}

// MnS1AsResourcesSliceNrm is a convenience function that returns MnS1 wrapped in ResourcesSliceNrm
func MnS1AsResourcesSliceNrm(v *MnS1) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		MnS1: v,
	}
}

// NetworkSliceSingleAsResourcesSliceNrm is a convenience function that returns NetworkSliceSingle wrapped in ResourcesSliceNrm
func NetworkSliceSingleAsResourcesSliceNrm(v *NetworkSliceSingle) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		NetworkSliceSingle: v,
	}
}

// NetworkSliceSubnetProviderCapabilitiesSingleAsResourcesSliceNrm is a convenience function that returns NetworkSliceSubnetProviderCapabilitiesSingle wrapped in ResourcesSliceNrm
func NetworkSliceSubnetProviderCapabilitiesSingleAsResourcesSliceNrm(v *NetworkSliceSubnetProviderCapabilitiesSingle) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		NetworkSliceSubnetProviderCapabilitiesSingle: v,
	}
}

// NetworkSliceSubnetSingleAsResourcesSliceNrm is a convenience function that returns NetworkSliceSubnetSingle wrapped in ResourcesSliceNrm
func NetworkSliceSubnetSingleAsResourcesSliceNrm(v *NetworkSliceSubnetSingle) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		NetworkSliceSubnetSingle: v,
	}
}

// SubNetworkSingle2AsResourcesSliceNrm is a convenience function that returns SubNetworkSingle2 wrapped in ResourcesSliceNrm
func SubNetworkSingle2AsResourcesSliceNrm(v *SubNetworkSingle2) ResourcesSliceNrm {
	return ResourcesSliceNrm{
		SubNetworkSingle2: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *ResourcesSliceNrm) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into EPTransportSingle
	err = newStrictDecoder(data).Decode(&dst.EPTransportSingle)
	if err == nil {
		jsonEPTransportSingle, _ := json.Marshal(dst.EPTransportSingle)
		if string(jsonEPTransportSingle) == "{}" { // empty struct
			dst.EPTransportSingle = nil
		} else {
			match++
		}
	} else {
		dst.EPTransportSingle = nil
	}

	// try to unmarshal data into FeasibilityCheckAndReservationJobSingle
	err = newStrictDecoder(data).Decode(&dst.FeasibilityCheckAndReservationJobSingle)
	if err == nil {
		jsonFeasibilityCheckAndReservationJobSingle, _ := json.Marshal(dst.FeasibilityCheckAndReservationJobSingle)
		if string(jsonFeasibilityCheckAndReservationJobSingle) == "{}" { // empty struct
			dst.FeasibilityCheckAndReservationJobSingle = nil
		} else {
			match++
		}
	} else {
		dst.FeasibilityCheckAndReservationJobSingle = nil
	}

	// try to unmarshal data into MnS1
	err = newStrictDecoder(data).Decode(&dst.MnS1)
	if err == nil {
		jsonMnS1, _ := json.Marshal(dst.MnS1)
		if string(jsonMnS1) == "{}" { // empty struct
			dst.MnS1 = nil
		} else {
			match++
		}
	} else {
		dst.MnS1 = nil
	}

	// try to unmarshal data into NetworkSliceSingle
	err = newStrictDecoder(data).Decode(&dst.NetworkSliceSingle)
	if err == nil {
		jsonNetworkSliceSingle, _ := json.Marshal(dst.NetworkSliceSingle)
		if string(jsonNetworkSliceSingle) == "{}" { // empty struct
			dst.NetworkSliceSingle = nil
		} else {
			match++
		}
	} else {
		dst.NetworkSliceSingle = nil
	}

	// try to unmarshal data into NetworkSliceSubnetProviderCapabilitiesSingle
	err = newStrictDecoder(data).Decode(&dst.NetworkSliceSubnetProviderCapabilitiesSingle)
	if err == nil {
		jsonNetworkSliceSubnetProviderCapabilitiesSingle, _ := json.Marshal(dst.NetworkSliceSubnetProviderCapabilitiesSingle)
		if string(jsonNetworkSliceSubnetProviderCapabilitiesSingle) == "{}" { // empty struct
			dst.NetworkSliceSubnetProviderCapabilitiesSingle = nil
		} else {
			match++
		}
	} else {
		dst.NetworkSliceSubnetProviderCapabilitiesSingle = nil
	}

	// try to unmarshal data into NetworkSliceSubnetSingle
	err = newStrictDecoder(data).Decode(&dst.NetworkSliceSubnetSingle)
	if err == nil {
		jsonNetworkSliceSubnetSingle, _ := json.Marshal(dst.NetworkSliceSubnetSingle)
		if string(jsonNetworkSliceSubnetSingle) == "{}" { // empty struct
			dst.NetworkSliceSubnetSingle = nil
		} else {
			match++
		}
	} else {
		dst.NetworkSliceSubnetSingle = nil
	}

	// try to unmarshal data into SubNetworkSingle2
	err = newStrictDecoder(data).Decode(&dst.SubNetworkSingle2)
	if err == nil {
		jsonSubNetworkSingle2, _ := json.Marshal(dst.SubNetworkSingle2)
		if string(jsonSubNetworkSingle2) == "{}" { // empty struct
			dst.SubNetworkSingle2 = nil
		} else {
			match++
		}
	} else {
		dst.SubNetworkSingle2 = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.EPTransportSingle = nil
		dst.FeasibilityCheckAndReservationJobSingle = nil
		dst.MnS1 = nil
		dst.NetworkSliceSingle = nil
		dst.NetworkSliceSubnetProviderCapabilitiesSingle = nil
		dst.NetworkSliceSubnetSingle = nil
		dst.SubNetworkSingle2 = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ResourcesSliceNrm)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ResourcesSliceNrm)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ResourcesSliceNrm) MarshalJSON() ([]byte, error) {
	if src.EPTransportSingle != nil {
		return json.Marshal(&src.EPTransportSingle)
	}

	if src.FeasibilityCheckAndReservationJobSingle != nil {
		return json.Marshal(&src.FeasibilityCheckAndReservationJobSingle)
	}

	if src.MnS1 != nil {
		return json.Marshal(&src.MnS1)
	}

	if src.NetworkSliceSingle != nil {
		return json.Marshal(&src.NetworkSliceSingle)
	}

	if src.NetworkSliceSubnetProviderCapabilitiesSingle != nil {
		return json.Marshal(&src.NetworkSliceSubnetProviderCapabilitiesSingle)
	}

	if src.NetworkSliceSubnetSingle != nil {
		return json.Marshal(&src.NetworkSliceSubnetSingle)
	}

	if src.SubNetworkSingle2 != nil {
		return json.Marshal(&src.SubNetworkSingle2)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ResourcesSliceNrm) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.EPTransportSingle != nil {
		return obj.EPTransportSingle
	}

	if obj.FeasibilityCheckAndReservationJobSingle != nil {
		return obj.FeasibilityCheckAndReservationJobSingle
	}

	if obj.MnS1 != nil {
		return obj.MnS1
	}

	if obj.NetworkSliceSingle != nil {
		return obj.NetworkSliceSingle
	}

	if obj.NetworkSliceSubnetProviderCapabilitiesSingle != nil {
		return obj.NetworkSliceSubnetProviderCapabilitiesSingle
	}

	if obj.NetworkSliceSubnetSingle != nil {
		return obj.NetworkSliceSubnetSingle
	}

	if obj.SubNetworkSingle2 != nil {
		return obj.SubNetworkSingle2
	}

	// all schemas are nil
	return nil
}

type NullableResourcesSliceNrm struct {
	value *ResourcesSliceNrm
	isSet bool
}

func (v NullableResourcesSliceNrm) Get() *ResourcesSliceNrm {
	return v.value
}

func (v *NullableResourcesSliceNrm) Set(val *ResourcesSliceNrm) {
	v.value = val
	v.isSet = true
}

func (v NullableResourcesSliceNrm) IsSet() bool {
	return v.isSet
}

func (v *NullableResourcesSliceNrm) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableResourcesSliceNrm(val *ResourcesSliceNrm) *NullableResourcesSliceNrm {
	return &NullableResourcesSliceNrm{value: val, isSet: true}
}

func (v NullableResourcesSliceNrm) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableResourcesSliceNrm) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
