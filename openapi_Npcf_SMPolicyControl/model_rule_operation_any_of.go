/*
Npcf_SMPolicyControl API

Session Management Policy Control Service   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved. 

API version: 1.3.0-alpha.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi_Npcf_SMPolicyControl

import (
	"encoding/json"
	"fmt"
)

// RuleOperationAnyOf the model 'RuleOperationAnyOf'
type RuleOperationAnyOf string

// List of RuleOperation_anyOf
const (
	CREATE_PCC_RULE RuleOperationAnyOf = "CREATE_PCC_RULE"
	DELETE_PCC_RULE RuleOperationAnyOf = "DELETE_PCC_RULE"
	MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS RuleOperationAnyOf = "MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS"
	MODIFY__PCC_RULE_AND_REPLACE_PACKET_FILTERS RuleOperationAnyOf = "MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS"
	MODIFY__PCC_RULE_AND_DELETE_PACKET_FILTERS RuleOperationAnyOf = "MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS"
	MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS RuleOperationAnyOf = "MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS"
)

// All allowed values of RuleOperationAnyOf enum
var AllowedRuleOperationAnyOfEnumValues = []RuleOperationAnyOf{
	"CREATE_PCC_RULE",
	"DELETE_PCC_RULE",
	"MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS",
	"MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS",
	"MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS",
	"MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS",
}

func (v *RuleOperationAnyOf) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := RuleOperationAnyOf(value)
	for _, existing := range AllowedRuleOperationAnyOfEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RuleOperationAnyOf", value)
}

// NewRuleOperationAnyOfFromValue returns a pointer to a valid RuleOperationAnyOf
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRuleOperationAnyOfFromValue(v string) (*RuleOperationAnyOf, error) {
	ev := RuleOperationAnyOf(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RuleOperationAnyOf: valid values are %v", v, AllowedRuleOperationAnyOfEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RuleOperationAnyOf) IsValid() bool {
	for _, existing := range AllowedRuleOperationAnyOfEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to RuleOperation_anyOf value
func (v RuleOperationAnyOf) Ptr() *RuleOperationAnyOf {
	return &v
}

type NullableRuleOperationAnyOf struct {
	value *RuleOperationAnyOf
	isSet bool
}

func (v NullableRuleOperationAnyOf) Get() *RuleOperationAnyOf {
	return v.value
}

func (v *NullableRuleOperationAnyOf) Set(val *RuleOperationAnyOf) {
	v.value = val
	v.isSet = true
}

func (v NullableRuleOperationAnyOf) IsSet() bool {
	return v.isSet
}

func (v *NullableRuleOperationAnyOf) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRuleOperationAnyOf(val *RuleOperationAnyOf) *NullableRuleOperationAnyOf {
	return &NullableRuleOperationAnyOf{value: val, isSet: true}
}

func (v NullableRuleOperationAnyOf) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRuleOperationAnyOf) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

